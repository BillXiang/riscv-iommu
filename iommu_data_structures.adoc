[[DATA_STRUCTURES]]
== Data Structures
A data structure called device-context (`DC`) is used by the IOMMU to associate
a device with an address space and to hold other per-device parameters used
by the IOMMU to perform address translations. A radix-tree data structure called
device directory table (DDT) that is traversed using the `device_id` is used to
locate the `DC`.

The address space used by a device may require single-stage or two-stage address
translation and protection. Two-stage address translation may required when the 
control of the device is passed through to a Guest OS. Single-stage address 
translation using a S-stage page table may be used when the control of the 
device is retained by the hypervisor or Host OS itself. 

When two-stage address translation is used the `DC` holds the PPN of the root
G-stage page table; a guest-soft-context-ID (`GSCID`), which facilitates fences
on a per-virtual-machine basis; and the G-stage address translation scheme.

Some devices supports multiple contexts where each context may be associated 
with a different process and thus a different virtual address space. The context
in such devices may be configured with a `process_id` that identifies the 
address space. When making a memory access, such devices signal the `process_id`
along with the `device_id` to identify the accessed address space. An example of
such a device is a GPU that supports multiple process contexts, where each
context is associated with a different user process, such that the GPU may 
access memory using the virtual address provided by the user process itself. To
support selecting an address space associated with the `process_id`, the `DC`
holds the PPN of the root Process Directory Table (PDT), a radix-tree data
structure, indexed using fields of the `process_id` to locate a data structure
called the Process Context (`PC`). 

When a PDT is active, the controls for S-stage or VS-stage address translation
are held in the (`PC`).

When a PDT is not active, the controls for S-stage or VS-stage address 
translation are be held in the `DC` itself.

The S/VS-stage address translation controls include the PPN of the root 
S/VS-stage page table; a process-soft-context-ID (`PSCID`), which facilitates
fences on a per-address-space basis; and the S/VS-stage address translation
scheme.

To handle MSIs from a device controlled by a guest OS, an IOMMU must be able to
redirect those MSIs to a guest interrupt file in an IMSIC. Because MSIs from 
devices are simply memory writes, they would naturally be subject to the same
address translation that an I/O MMU applies to other memory writes. However, 
the Advanced Interrupt Architecture defines IOMMU support to treat MSIs 
directed to virtual machines specially, in part to simplify software, and in 
part to allow optional support for memory-resident interrupt files. The Advanced
Interrupt Architecture adds to device contexts an MSI address mask and address
pattern, used together to recognize certain memory writes from the device as
being MSIs; and the real physical address of an MSI page table for controlling
the translation and/or conversion of MSIs from the device.

The `DC` further holds controls for the type of transactions that a device is
allowed to generate. One example of such a control is whether the device is 
allowed to use the PCIe defined Address Translation Service (ATS).

Two formats of the device-context structure are supported:

* *Base Format* - is 32-bytes in size used when the special treatment of MSI 
  as defined by the Advanced Interrupt Architecture is not supported by the 
  IOMMU.

* *Extended Format* - is 64-bytes in size and extends the base format `DC` with
  additional fields to process MSIs as defined by the RISC-V Advanced interrupt
  Architecture (AiA).

The DDT used to locate the `DC` may be configured to be a 1, 2, or 3 level 
radix-table depending on the maximum width of the `device_id` supported. The
partitioning of the `device_id` to obtain the device directory indexes (DDI) to
traverse the DDT radix-tree table are as follows:

.Base format `device_id` partitioning

[wavedrom, , ]
....
{reg: [
  {bits: 7, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 8, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

.Extended format `device_id` partitioning

[wavedrom, , ]
....
{reg: [
  {bits: 6, name: 'DDI[0]'},
  {bits: 9, name: 'DDI[1]'},
  {bits: 9, name: 'DDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....

The PDT may be configured to be a 1, 2, or 3 level radix table depending on the
maximum width of the `process_id` supported for that device.  The partitioning
of the `process_id` to obtain the process directory indices (PDI) to traverse 
the PDT radix-tree table are as follows:

.`process_id` partitioning for PDT radix-tree traversal

[wavedrom, , ]
....
{reg: [
  {bits: 8, name: 'PDI[0]'},
  {bits: 9, name: 'PDI[1]'},
  {bits: 3, name: 'PDI[2]'},
], config:{lanes: 1, hspace:1024, fontsize: 16}}
....
[NOTE]
====
The `process_id` partitioning is designed to required a maximum of 4 KiB, a
page, of memory for each process directory table. The root of the table when
using a 20-bit wide `process_id` is not fully populated. The option of making
the root table occupy 32 KiB was considered but not adopted as these tables
are allocated at run time and contiguous memory allocation larger than a page
may stress the Guest and hypervisor memory allocators.
====

[NOTE]
====
All RISC-V IOMMU implementations are required to support DDT and PDT located
in main memory. Supporting data structures in I/O memory is not required but
is not prohibited by this specification.
====

=== Device-Directory-Table (DDT)
DDT is up to 3-level radix tree indexed using the device directory index (DDI)
bits of the `device_id`.

The following diagrams illustrate the DDT radix-tree. The PPN of the root 
device-directory-table is held in a memory-mapped register called the
device-directory-table pointer (`ddtp`). 

Each valid non-leaf (`NL`) entry is 8-bytes in size and holds the PPN of the 
next device-directory-table.

A valid leaf device-directory-table entry holds the device-context (`DC`).

.Three, two and single-level device directory with extended format `DC`
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+    +-------+
  |DDI[2] |DDI[1] |DDI[0] |      |DDI[1] |DDI[0] |    |DDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+    +-+-----+
     |       |       |             |       |            |
     +-9-bit +-9-bit +-6-bit       +-9-bit +-6-bit      +-6-bit
     |       |       |             |       |            |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+      |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |      |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+      |   |  |
     |  |  | |  |  | +->|DC|       |  |  | +->|DC|      |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+      |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |      |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |      |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |      +-->|DC|
        |NL+-+  |  | |  |  |          |  | |  |  |          +--+
        +--+ |  |  | |  |  |          |  | |  |  |          |  |
        |  | |  |  | |  |  |          |  | |  |  |          |  |
ddtp--->+--+ +->+--+ +->+--+  ddtp--->+--+ +->+--+  ddtp--->+--+
....

.Three, two and single-level device directory with base format `DC`
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+    +-------+
  |DDI[2] |DDI[1] |DDI[0] |      |DDI[1] |DDI[0] |    |DDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+    +-+-----+
     |       |       |             |       |            |
     +-8-bit +-9-bit +-7-bit       +-9-bit +-7-bit      +-7-bit
     |       |       |             |       |            |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+      |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |      |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+      |   |  |
     |  |  | |  |  | +->|DC|       |  |  | +->|DC|      |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+      |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |      |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |      |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |      +-->|DC|
        |NL+-+  |  | |  |  |          |  | |  |  |          +--+
        +--+ |  |  | |  |  |          |  | |  |  |          |  |
        |  | |  |  | |  |  |          |  | |  |  |          |  |
ddtp--->+--+ +->+--+ +->+--+  ddtp--->+--+ +->+--+  ddtp--->+--+
....

==== Non-leaf DDT entry

A valid (`V==1`) non-leaf DDT entry provides PPN of the next level DDT.

.Non-leaf device-directory-table entry

[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 11, name: 'reserved', attr: '11'},
  {bits: 44, name: 'PPN',      attr: '44'},
  {bits: 8,  name: 'reserved', attr: '8'},
], config:{lanes: 2, hspace:1024, fontsize: 16}}
....

==== Leaf DDT entry
The leaf DDT page is indexed by `DDI[0]` and holds the device-context (`DC`).

In base-format the `DC` is 32-bytes. In extended-format the `DC` is 64-bytes.

.Base-format device-context
[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

.Extended-format device-context
[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'Translation-control (tc)'},
  {bits: 64,  name: 'IO Hypervisor guest address translation and protection (iohgatp)'},
  {bits: 64,  name: 'First-stage-context (fsc)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
  {bits: 64,  name: 'MSI-page-table pointer (msiptp)'},
  {bits: 64,  name: 'MSI-address-mask (msi_addr_mask)'},
  {bits: 64,  name: 'MSI-address-pattern (msi_addr_pattern)'},
  {bits: 64,  name: 'reserved'},
], config:{lanes: 8, hspace: 1024, fontsize: 16}}
....

==== Device-context fields
===== Translation control (`tc`)

.Translation control (`tc`) field
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V'},
  {bits: 1,  name: 'EN_ATS'},
  {bits: 1,  name: 'EN_PRI'},
  {bits: 1,  name: 'T2GPA'},
  {bits: 1,  name: 'DTF'},
  {bits: 1,  name: 'PDTV'},
  {bits: 1,  name: 'PRPR'},
  {bits: 25, name: 'reserved'},
  {bits: 32, name: 'for custom use'},
], config:{lanes: 4, hspace: 1024, fontsize: 16, fontsize: 16}}
....

`DC` is valid if the `V` bit is 1; If it is 0, all other bits in `DC` are
don't-care and may be freely used by software.

If the IOMMU supports PCIe ATS specification (see `capabilities` register),
the `EN_ATS` bit is used to enable ATS transaction processing. If `EN_ATS`
is set to 1, IOMMU supports the following inbound transactions; otherwise
they are treated as unsupported transactions.

* Translated read for execute transaction
* Translated read transaction
* Translated write/AMO transaction
* PCIe ATS Translation Request
* PCIe ATS Invalidation Completion Message

If the `EN_ATS` bit is 1 and the `T2GPA` bit is set to 1 the IOMMU returns a GPA
, instead of a SPA, as the translation of an IOVA in response to a  PCIe ATS
Translation Request from the device.  In this mode of operations, the ATC in the
device caches a GPA as a translation for an IOVA and uses the GPA as the address
in subsequent translated memory access transactions. Usually translated requests
use a SPA and need no further translation to be performed by the IOMMU. However 
when `T2GPA` is 1, translated requests from a device use a GPA and are
translated by the IOMMU using the G-stage page table to a SPA. The `T2GPA` 
control enables a hypervisor to contain DMA from a device, even if the device
misuses the ATS capability and attempts to access memory that is not associated
with the VM.

[NOTE]
====
When `T2GPA` is enabled, the addresses provided to the device in response to a
PCIe ATS Translation Request are not directly routable by the I/O fabric
(e.g. PCI switches) that connect the device to other peer devices and to host.
Such addresses are also not routable within the device even if peer-to-peer
transactions within the device (e.g. between functions of a device) are 
supported.

Hypervisors that configure `T2GPA` to 1 must ensure through protocol specific
means that translated accesses are routed through the host such that the IOMMU
may translate the GPA and then route the transaction based on PA to memory or
to a peer device. For PCIe, for example, the Access Control Service (ACS) may
be configured to always redirect peer-to-peer (P2P) requests upstream to the
host.

Use of `T2GPA` set to 1 may not be compatible with devices that implement caches
tagged by the translated address returned in response to a PCIe ATS Translation
Request.

As an alternative to setting `T2GPA` to 1, the hypervisor may establish a trust
relationship with the device if authentication protocols are supported by the
device. For PCIe, for example, the PCIe component measurement and authentication
(CMA) capability provides a mechanism to verify the devices configuration and 
firmware/executable (Measurement) and hardware identities (Authentication) to 
establish such a trust relationship.
====

If `EN_PRI` bit is 0, then PCIe "Page Request" messages from the device are 
invalid requests. A "Page Request" message received from a device is responded to
with a "Page Request Group Response" message. Normally, a software handler 
generates this response message. However, under some conditions the IOMMU itself 
may generate a response. For IOMMU generated "Page Request Group Response" 
messages the PRG-response-PASID-required (`PRPR`) bit when set to 1 indicates 
that the IOMMU response message should include a PASID prefix if the associated
"Page Request" had a PASID prefix.

[NOTE]
====
Functions that support PASID and have the "PRG Response PASID Required" 
capability bit set to 1, expect that "Page Request Group Response" messages will
contain a PASID if the associated "Page Request" message had a PASID. If the 
capability bit is 0, the function does not expect PASID on any "Page Request 
Group Response" message and the behavior of the function if it receives the 
response with a PASID prefix is undefined. The `PRPR` bit should be configured
with the value held in the "PRG Response PASID Required" capability bit.
====

[NOTE]
====
When SR-IOV VF is used as a unit of allocation, a hypervisor may disable page
requests from one of the virtual functions by setting `EN_PRI` to 0. However the
page-request interface is shared by the PF and all VFs. The IOMMU protocol
specific logic is encouraged to classify this condition as a non-catastrophic
failure in its response to avoid the shared PRI in the device being disabled
for all PFs/VFs.
====

Setting the disable-translation-fault - `DTF` - bit to 1 disables reporting of
faults encountered in the address translation process. Setting `DTF` to 1 does
not disable error responses from being generated to the device in response to
faulting transactions. Setting `DTF` to 1 does not disable reporting of faults
from the IOMMU that are not related to the address translation process. The 
faults that are not reported when `DTF` is 1 are listed in <<FAULT_CAUSE>>.

[NOTE]
====
A hypervisor may set `DTF` to 1 to disable fault reporting when it has
identified conditions that may lead to a flurry of errors such as due to an
abnormal termination of a virtual machine.
====

The `fsc` field of `DC` holds the context for first-stage translations (S-stage
or VS-stage). If the `PDTV` bit is 1, the field holds the PPN of the root page 
of PDT.  If the `PDTV` bit is 0 and `iohgatp.MODE` is `Bare`, the `fsc` field
holds the PPN of the root page of a S-stage page table (i.e. `iosatp`).
if the `PDTV` bit is 0 and `iohgatp.MODE` is not `Bare`, the `fsc` field holds
the PPN of the root page of a VS-stage page table (i.e. `iovsatp`).

The `PDTV` is expected to be set to 1 when `DC` is associated with a device
that supports multiple process contexts and thus generates a valid `process_id`
with its memory accesses. For PCIe, for example, PASID capable devices that 
have the PASID capability enabled, signal the `process_id` in the PASID TLP
prefix of the TLP.

===== IO hypervisor guest address translation and protection (`iohgatp`)
The `iohgatp` field holds the PPN of the root G-stage page table and a
virtual machine identified by a guest soft-context ID (`GSCID`), to facilitate
address-translation fences on a per-virtual-machine basis. If multiple devices
are associated to a VM with a common G-stage page table, the hypervisor is
expected to program the same `GSCID` in each `iohgatp`. The `MODE` field is used
to select the G-stage address translation scheme.

The G-stage page table format and `MODE` encoding follow the format defined by
the privileged specification.

Implementations are not required to support all defined mode settings for
`iohgatp`. The IOMMU only needs to support the modes also supported by the MMU
in the harts integrated into the system or a subset thereof.

.IO hypervisor guest address translation and protection (`iohgatp`) field
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'GSCID'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....


===== First-Stage context (`fsc`)
If `PDTV` is 0, the `fsc` field in `DC` holds the `iosatp` (when `iohgatp MODE`
is `Bare`) or the `iovsatp` (when `iohgatp MODE` is not `Bare`) that provide the
controls for S-stage page table or VS-stage address translation and protection
respectively.

.IO (Virtual)Supervisor addr. translation and prot. (`iovsatp`/`iosatp`) field (when `PDTV` is 0)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The encoding of the `iosatp`/`iovsatp` `MODE` field are as the same as the
encoding for `MODE` field in the `satp` CSR.

When `PDTV` is 1, the `fsc` field holds the process-directory table pointer
(`pdtp`). When the device supports multiple process contexts, selected by the
`process_id`, the PDT is used to determine the S/VS-stage page table and
associated `PSCID` for virtual address translation and protection.

The `pdtp` field holds the PPN of the root PDT and the `MODE` field that 
determines the number of levels of the PDT.

.Process-directory table pointer (`pdtp`) field (when `PDTV` is 1)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

When two-stage address translation is active (`iohgatp.MODE != Bare`), the `PPN`
field holds a guest PPN.  The GPA of the root PDT is then converted by guest
physical address translation, as controlled by the `iohgatp`, into a supervisor
physical address. Translating addresses of root PDT root through G-stage page
tables, allows the PDT to be held in memory allocated by the guest OS and allows
the guest OS to directly edit the PDT to associate a virtual-address space
identified by a VS-stage page table with a `process_id`.

.Encoding of `pdtp.MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection. First stage translation is
                    not enabled.
| 1    | `PD20`   | 20-bit process ID enabled. The directory has 3 levels.
                    The root PDT has 8 entries and the next non-leaf
                    level has 512 entries. The leaf level has 256 entries.
| 2    | `PD17`   | 17-bit process ID enabled. The directory has 2 levels.
                    The root PDT page has 512 entries and leaf level has
                    256 entries. The bits 19:17 of `process_id` must be 0.
| 3    | `PD8`    | 8-bit process ID enabled. The directory has 1 levels with
                    256 entries.The bits 19:8 of `process_id` must be 0.
| 3-15 | --       | Reserved
|===

===== Translation attributes (`ta`)

.Translation attributes (`ta`) field
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'reserved'},
  {bits: 20, name: 'PSCID'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

The `PSCID` field of `ta` provides the process soft-context ID that identifies
the address-space of the process. `PSCID` facilitates address-translation
fences on a per-address-space basis. The `PSCID` field in `ta` is used as the
address-space ID if `PDTV` is 0 and the `iosatp`/`iovsatp` `MODE` field is not
`Bare`.

===== MSI page table pointer (`msiptp`)

The `msiptp` field holds the PPN of the root MSI page table used to direct an
MSI to a guest interrupt file in an IMSIC. The MSI page table format is defined
in Section 9.5 of the Advanced Interrupt Architecture (AIA) specification.

The `MODE` field is used to select the MSI address translation scheme.

.MSI page table pointer (`msiptp`) field
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

.Encoding of `msiptp` `MODE` field
[width=75%]
[%header, cols="3,3,20"]
|===
|Value | Name     | Description
| 0    | `Bare`   | No translation or protection. MSI recognition using
                    MSI address mask and pattern is not performed.
| 1    | `Flat`   | Flat MSI page table (see Section 9.5 of the AiA specification)
|===

===== MSI address mask (`msi_addr_mask`) and pattern (`msi_addr_pattern`)

The MSI address mask (`msi_addr_mask`) and pattern (`msi_addr_pattern`) fields
are used to recognize certain memory writes from the device as being MSIs. The
use of these fields is as specified in Section 9.4 of the Advanced Interrupt
Architecture specification.

=== Process-Directory-Table (PDT)

The PDT is a 1, 2, or 3-level radix tree indexed using the process directory
index (`PDI`) bits of the `process_id`.

The following diagrams illustrate the PDT radix-tree. The root
process-directory page number is located using the process-directory-table
pointer (`pdtp`) field of the device-context. Each non-leaf (`NL`) entry
provides the PPN of the next level process-directory-table. The leaf
process-directory-table entry holds the process-context (`PC`).

.Three, two and single-level process directory
["ditaa",shadows=false, separation=false, font=courier, fontsize: 16]
....
  +-------+-------+-------+      +-------+-------+   +-------+
  |PDI[2] |PDI[1] |PDI[0] |      |PDI[1] |PDI[0] |   |PDI[0] |
  +--+----+--+----+--+----+      +-+-----+-+-----+   +-+-----+
     |       |       |             |       |           |
     +-3-bit +-9-bit +-8-bit       +-9-bit +-8-bit     +-8-bit
     |       |       |             |       |           |
     |  +--+ |  +--+ |  +--+       |  +--+ |  +--+     |   +--+
     |  |  | |  |  | |  |  |       |  |  | |  |  |     |   |  |
     |  |  | |  |  | |  +--+       |  |  | |  +--+     |   |  |
     |  |  | |  |  | +->|PC|       |  |  | +->|PC|     |   |  |
     |  |  | |  +--+    +--+       |  |  |    +--+     |   |  |
     |  |  | +->|NL+-+  |  |       |  +--+    |  |     |   |  |
     |  |  |    +--+ |  |  |       +->|NL+-+  |  |     |   +--+
     +->+--+    |  | |  |  |          +--+ |  |  |     +-->|PC|
        |NL+-+  |  | |  |  |          |  | |  |  |         +--+
        +--+ |  |  | |  |  |          |  | |  |  |         |  |
        |  | |  |  | |  |  |          |  | |  |  |         |  |
pdtp--->+--+ +->+--+ +->+--+  pdtp--->+--+ +->+--+ pdtp--->+--+
....

==== Non-leaf PDT entry

A valid (`V==1`) non-leaf PDT entry holds the PPN of the next-level PDT.

.Non-leaf process-directory-table entry

[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 11, name: 'reserved', attr: '11'},
  {bits: 44, name: 'PPN',      attr: '44'},
  {bits: 8,  name: 'reserved', attr: '8'},
], config:{lanes: 2, hspace:1024, fontsize: 16}}
....

==== Leaf PDT entry
The leaf PDT page is indexed by `PDI[0]` and holds the 16-byte process-context
(`PC`).

.Process-context

[wavedrom, , ]
....
{reg: [
  {bits: 64,  name: 'First-stage-context (fsc)'},
  {bits: 64,  name: 'Translation-attributes (ta)'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

==== Process-context fields

===== Translation attributes (`ta`)

.Translation attributes (`ta`) field
[wavedrom, , ]
....
{reg: [
  {bits: 1,  name: 'V',        attr: '1'},
  {bits: 1,  name: 'ENS',     attr: '1'},
  {bits: 1,  name: 'SUM',    attr: '1'},
  {bits: 41, name: 'reserved', attr: '42'},
  {bits: 20, name: 'PSCID',    attr: '20'},
], config:{lanes: 4, hspace: 1024, fontsize: 16}}
....

`PC` is valid if the `V` bit is 1; If it is 0, all other bits in `PC` are don't
care and may be freely used by software.

When Enable-Supervisory-access (`ENS`) is 1, transactions requesting supervisor
privilege are allowed with this `process_id` else the transaction is treated as
an unsupported transaction.

When `ENS` is 1, the `SUM` (permit Supervisor User Memory access) bit
modifies the privilege with which supervisor privilege transactions access
virtual memory. When `SUM` is 0, supervisor privilege transactions to pages
mapped with `U`-bit in PTE set to 1 will fault.

When `ENS` is 1, supervisor privilege transactions that read with execute
intent to pages mapped with `U` bit in PTE set to 1 will fault, regardless of
the state of `SUM`.

===== First-Stage context (`fsc`)
If `PDTV` is 0, the `fsc` field in `DC` holds the `iosatp` (when `iohgatp MODE`
is `Bare`) or the `iovsatp` (when `iohgatp MODE` is not `Bare`) that provide 
the controls for S-stage page or VS-stage address translation and protection
respectively.

.IO (Virtual)Supervisor addr. translation and prot. (`iovsatp`/`iosatp`) field (when `PDTV` is 1)
[wavedrom, , ]
....
{reg: [
  {bits: 44, name: 'PPN'},
  {bits: 16, name: 'reserved'},
  {bits: 4,  name: 'MODE'},
], config:{lanes: 2, hspace: 1024, fontsize: 16}}
....

A valid (`V==1`) leaf PDT entry holds the PPN of the root page of a S/VS-stage
page table and the `MODE` used to determine the S/VS-stage address translation
scheme. The `MODE` field encoding are as defined for the `MODE` field in the
`satp`/`vsatp` CSR.

The software assigned process soft-context ID (`PSCID`) is used as the address
space ID for the process identified by the S/VS-stage page table.

When two-stage address translation is active (`iohgatp.MODE != Bare`), the `PPN`
field holds a guest PPN of the root of a VS-stage page table. Addresses of the 
VS-stage page table entries are then converted by guest physical address
translation process, as controlled by the `iohgatp`, into a supervisor physical
address. A guest OS may thus directly edit the VS-stage page table to limit
access by the device to a subset of its memory and specify permissions for the
device accesses.

=== Process to translate an IOVA
The process to translate an `IOVA` is as follows:

. Use `device_id` to then locate the device-context (`DC`) as specified in
  <<GET_DC>>.
. If `DC.tc.pdtv` is set to 0, the `device_id` does not support a
  `process_id`; go to step 4 with the following page table information:
** If a G-stage page table is not active in the device-context
   (`DC.iohgatp.mode` is `Bare`) then S-stage page-table is defined in
   the first-stage context (`DC.fsc`) as it holds the `iosatp`. `DC.ta` holds
   the `PSCID` associated with the S-stage translation.
** If a G-stage page table is active in the device-context (`DC.iohgatp.mode`
   is not `Bare`), then VS-stage page table is defined in the first-stage
   context (`DC.fsc`) as it holds the `iovsatp` and the G-stage page table is
   defined in `DC.iohgatp`, which also holds the `GSCID`. `DC.ta` holds the
   `PSCID` associated with the VS-stage translation.
. If `DC.tc.pdtv` is set to 1, the `device_id` supports a `process_id` and
  `DC.fsc` holds the `pdtp`;locate the process-context (`PC`) as specified in
  <<GET_PC>>.
** If a G-stage page table is not active in the device-context
   (`DC.iohgatp.mode` is `Bare`) then S-stage page-table is defined in the
   first-stage context (`PC.fsc`) as it holds the `iosatp`. `PC.ta` holds the
   `PSCID` associated with the S-stage translation.
** If a G-stage page table is active in the device-context
   (`DC.iohgatp.mode` is not `Bare`), then VS-stage page table is defined in
   the first-stage context (`PC.fsc`) as it holds the `iovsatp` and the G-stage
   page table is defined in `DC.iohgatp`, which also holds the `GSCID`. `PC.ta`
   holds the `PSCID` associated with the VS-stage translation.
. If the transaction is a write and the IOMMU support MSI address translation using
  MSI flat page tables then determine if the `IOVA` is a MSI address and translate
  it using MSI address translation process specified in <<MSI_TRANS>>.
. If a G-stage page table is not active in the device-context then use the
  single stage address translation process specified in Section 4.3.2 of the
  RISC-V privileged specification. If a fault is detecting by the single stage
  address translation process then stop and report the fault.
. If a G-stage page table is active in the device-context then use the
  two-stage address translation process specified in Section 8.5 of the RISC-V
  privileged specification. If a fault is detecting by the single stage address
  translation process then stop and report the fault.

When the translation process reports a fault, and the request is a Untranslated
request, a Translated request, or a message the IOMMU requests the IO bridge to
abort the transaction. Guidelines for handling faulting transactions in the IO 
bridge are provided in <<IOBR_FAULT_RESP>>. The fault may be reported using the 
fault/event reporting mechanism and fault record formats specified in 
<<FAULT_QUEUE>>. 

If the fault was detected by a PCIe ATS Translation Request then the IOMMU may 
provide a PCIe protocol defined response instead of reporting fault to software
or causing an abort. The handling of faulting PCIe ATS Translation Requests is 
specified in <<ATS_FAULTS>>.

[[GET_DC]]
==== Process to locate the Device-context

The process to locate the Device-context for transaction using its `device_id`
is as follows:

. If `ddtp.iommu_mode == Off` then stop and report "All inbound transactions
  disallowed" (cause = 256).
. Let `a` be `ddtp.PPN x 2^12^` and let `i = LEVELS - 1`. When
  `ddtp.iommu_mode` is `3LVL`, `LEVELS` is three. When `ddtp.iommu_mode` is
  `2LVL`, `LEVELS` is two. When `ddtp.iommu_mode` is `1LVL`, `LEVELS` is one.
  . If the `device_id` is wider than supported by `ddtp.iommu_mode`, then stop
  and report "Transaction type disallowed" (cause = 260).
. If `i == 0` go to step 9.
. Let `ddte` be value of eight bytes at address `a + DDI[i] x 8`. If accessing
  `ddte` violates a PMA or PMP check, then stop and report "DDT entry load 
  access fault" (cause = 257).
. If `ddte.V == 0`, stop and report "DDT entry not valid" (cause = 258).
. If if any bits or encoding that are reserved for future standard use are
  set within `ddte`, stop and report "DDT entry misconfigured"
  (cause = 259).
. Let `i = i - 1` and let `a = ddte.PPN x 2^12^`. Go to step 4.
. Let `dc` be value of `DC_SIZE` bytes at address `a + DDI[0]*DC_SIZE`. If
  `capabilities.MSI_FLAT` is 1 then `DC_SIZE` is 64-bytes else it is 32-bytes.
  If accessing `dc` violates a PMA or PMP check, then stop and report 
  "DDT entry load access fault" (cause = 257).
. If `dc.tc.V == 0`, stop and report "DDT entry not valid" (cause = 258).
. If any bits or encoding that are reserved for future standard use are set
  within `dc`, stop and report "DDT entry misconfigured" (cause = 259).
. if any of the following conditions hold then stop and report
  "Transaction type disallowed" (cause = 260).
..  Transaction type is a Translated request (read, write/AMO, read-for-execute)
    or is a PCIe ATS Translation request or is a ATS protocol message request
    and `dc.tc.EN_ATS` is 0.
..  Transaction type is a PCIe "Page Request" Message and `dc.tc.EN_PRI` is 0.
..  Transaction has a valid `process_id` and `dc.tc.PDTV` is 0
..  Transaction has a valid `process_id` and `dc.tc.PDTV` is 1 and the `process_id`
    is wider than supported by `pdtp.MODE`.
..  Transaction type is not supported by the IOMMU.
.   The device-context has been successfully located.

[[GET_PC]]
==== Process to locate the Process-context

The device-context provides the PDT root page PPN (`pdtp.ppn`).  When 
`DC.iohgatp.mode` is not bare, `pdtp.PPN` as well as `pdte.PPN` are Guest 
Physical Addresses (GPA) which must be translated into Supervisor Physical
Addresses (SPA) using the G-stage page table pointed by `DC.iohgatp`.

The process to locate the Process-context for a transaction using its
`process_id` is as follows:

. Let `a` be `pdtp.PPN x 2^12^` and let `i = LEVELS - 1`. When
  `pdtp.MODE` is `PD20`, `LEVELS` is three. When `pdtp.MODE` is
  `PD17`, `LEVELS` is two. When `pdtp.MODE` is `PD8`, `LEVELS` is one.
. If `DC.iohgatp.mode != Bare`, then `a` is a GPA. Invoke the process
  to translate `a` to a SPA. If faults occur during G-stage address 
  translation of `a` then stop and the fault detected by the G-stage 
  address translation process. The translated `a` is used in subsequent
  steps. 
. If `i == 0` go to step 8.
. Let `pdte` be value of eight bytes at address `a + PDI[i] x 8`. If 
  accessing `pdte` violates a PMA or PMP check, then stop and report 
  "PDT entry load access fault" (cause = 265).
. If `pdte.V == 0`, stop and report "PDT entry not valid" (cause = 266).
. If if any bits or encoding that are reserved for future standard use are
  set within `pdte`, stop and report "PDT entry misconfigured" (cause = 267).
. Let `i = i - 1` and let `a = pdte.PPN x 2^12`. Go to step 2.
. Let `pc` be value of 16-bytes at address `a + PDI[0] x 16`. If accessing `pc`
  violates a PMA or PMP check, then stop and report "PDT entry load access 
  fault" (cause = 265).
. If `pc.ta.V == 0`, stop and report "PDT entry not valid" (cause = 266).
. If any bits or encoding that are reserved for future standard use are set
  within `pc`, stop and report "PDT entry misconfigured" (cause = 267).
. if any of the following conditions hold then stop and report
  "Transaction type disallowed" (cause = 260).
..  The transaction requests supervisor privilege but `pc.ta.ENS` is not set.
. The Process-context has been successfully located.

[[MSI_TRANS]]
==== Process to translate addresses of MSIs

When MSI address translation using MSI flat PTE is supported, the process to
identify a incoming 32-bit write made by a device as a MSI write and
translating the write using the MSI page table is as follows:

. Let `A` be a 32-bit aligned 32-bit write from from a device.
. Let `dc` be the device-context located using the `device_id` of the device
  using the process outlined in <<GET_DC>>.
. If `dc.msiptp.MODE == Bare`, then MSI address translation using MSI page
  tables is not enabled. Stop this process and instead use the regular
  translation data structures to do the address translation.
. If `(A >> 12) & dc.msi_addr_mask` is not equal to
  `dc.msi_addr_pattern & dc.msi_addr_mask` then this write is not a MSI write.
  Stop this process and instead use the regular translation data structures to
  do the address translation.
. Let the interrupt file number `I` be `extract((A >> 12), dc.msi_addr_mask)`.
  The `extract` function here is the same generic bit extract performed by
  RISC-V instruction BEXT.
. Let `a` be `(dc.msiptp.PPN x 2^12^)`.
. Let `msipte` be the value of sixteen bytes at address `(a | (I x 16))`. If
  accessing `msipte` violates a PMA or PMP check, then stop and report 
  "MSI PTE load access fault" (cause = 261).
. If `msipte.V == 0`, then stop and report "MSI PTE not valid" (cause = 262).
. If `msipte.C == 1`, then further process is to interpret the PTE is
  implementation defined. If `msipte.C == 0` then the process is outlined in
  subsequent steps.
. If `msipte.W == 1` the PTE is write-through mode PTE and the translation
  process is as follows:
.. If any bits or encoding that are reserved for future standard use are set
   within `msipte`, stop and report "MSI PTE misconfigured" (cause = 262).
.. Translate the address as outlined in Section 9.5.1 of the Advanced
   Interrupt Architecture specification.
. If `msipte.W == 0` the PTE is a MRIF mode PTE and the translation process
  is as follows:
.. If `capabilities.MSI_MRIF == 0`, stop and report "MSI PTE misconfigured"
   (cause = 262).
.. If any bits or encoding that are reserved for future standard use are
   set within `msipte`, stop and report "MSI PTE misconfigured" (cause = 262).
.. Perform the process as outlined in Section 9.5.2 of the Advanced Interrupt
   Architecture specification. If accessing MRIF violates a PMA or PMP check,
   then stop and report "MRIF access fault" (cause = 264).
. MSI address translation process is complete.

=== Faults from virtual address translation process

Faults detected during the S-stage or two-stage address translation specified
in the privileged specification cause the IOVA translation process to stop and
report the detected fault.

[[ATS_FAULTS]]
=== PCIe ATS translation request handling
ATS translation requests that encounter a configuration error results in a 
Completer Abort (CA) response to the requester. The following cause codes
belong to this category:

* Instruction access fault (cause = 1)
* Read access fault (cause = 5)
* Write/AMO access fault (cause = 7)
* MSI PTE load access fault (cause = 261)
* MSI PTE misconfigured (cause = 263)
* PDT entry load access fault (cause = 265)
* PDT entry misconfigured (cause = 267)

If there is a permanent error or if ATS transactions are disabled then a 
Unsupported Request (UR) response is generated. The following cause codes
belong to this category:

* All inbound transactions disallowed (cause = 256)
* DDT entry load access fault (cause = 257)
* DDT entry not valid (cause = 258)
* DDT entry misconfigured (cause = 259)
* Transaction type disallowed (cause = 260)

When translation could not be completed due to PDT entry being not present, MSI
PTE being not present, or first and/or second stage PTE being not present or 
misconfigured then a Success Response with R and W bits set to 0 is generated. 
The translated address returned with such completions is undefined. The 
following cause codes belong to this category:

* Instruction page fault (cause = 12)
* Read page fault (cause = 13)
* Write/AMO page fault (cause = 14)
* Instruction guest page fault (cause = 20)
* Read guest-page fault (cause = 21)
* Write/AMO guest-page fault (cause = 23)
* PDT entry not valid (cause = 266)
* MSI PTE not valid (cause = 262)

If the translation request has a PASID prefix with "Privilege Mode Requested" 
field set to 0, or the request does not have a PASID prefix then the request 
does not target privileged memory. If the U-bit that indicates if the memory is
accessible to user mode is 0 then a Success response with R and W bits set to 0
is generated.

If the translation request has a PASID prefix with "Privilege Mode Requested"
field set to 1, then the request targets privileged memory. If the U-bit that
indicates if the page is accessible to user mode is 1 and the `SUM` bit in `ta`
field of the process-context is 0 then a Success response with R and W bits set
to 0 is generated.

If the translation could be successfully completed but the requested 
permissions are not present (Execute requested but no execute permission; 
no-write not requested and no write permission; no read permission)
then a Success response is returned with the denied permission (R, W or X) 
set to 0 and the other permission bits set to value determined from the
page tables. The X permission is granted only if the R permission is also
granted. Execute-only translations are not compatible with PCIe ATS as PCIe
requires read permission to be granted if the execute permission is granted.

When a Success response is generated for a ATS translation request, no fault
records are reported to software through the fault/event reporting mechanism;
even when the response indicates no access was granted or some permissions were
denied.

If the translation request has an address determined to be an MSI address using
the rules defined by the AiA specification but the MSI PTE is configured in MRIF
mode then a Success response is generated with R, W, and U bit set to 1. The U 
bit being set to 1 in the response instructs the device that it must only use
Untranslated requests to access the implied 4 KiB memory range.

[NOTE]
====
When a MSI PTE is configured in MRIF mode, a MSI write with data value D
requires the IOMMU to set the interrupt-pending bit for interrupt identity D
in the MRIF. A translation request from a device to a GPA that is mapped 
through a MRIF mode MSI PTE is not eligible to receive a translated address. 
This is accomplished by setting "Untranslated Access Only" (U) field of the 
returned response to 1.
====

When a Success response is generated for a ATS translation request, the setting
of the Priv, N, CXL.io, and AMA fields is as follows:

* Priv field of the ATS translation completion is always set to 0 if the request
  does not have a PASID prefix. When a PASID prefix is present then the Priv 
  field is set to the value in "Privilege Mode Requested" field as the 
  permissions provided correspond to those the privilege mode indicate in the 
  request.
* N field of the ATS translation completion is always set to 0. The device may
  use other means to determine if the No-snoop flag should be set in the 
  translated requests.
* If requesting device is not a CXL device then CXL.io is set to 0. 
* If requesting device is a CXL type 1 or type 2 device and the memory
  attribute, as determined by the Svpbmt extension, is NC or IO then the CXL.io
  bit is set to 1. If the Svpbmt extension is not supported then the setting of
  this bit is unspecified.
* The AMA field is by default set to 000b. The IOMMU may support an 
  implementation specific method to provide other encodings.

=== Caching in-memory data structures

To speed up Direct Memory Access (DMA) translations, the IOMMU may make use of
translation caches to hold entries from device-directory-table,
process-directory-table, S/VS and G-stage translation tables, MSI page
tables. These caches are collectively referred to as the IOMMU Address
Translation Caches (IOATC).

This specification does not allow the caching of S/VS/G-stage PTEs whose `V` 
(valid) bit is clear, non-leaf DDT entries whose `V` (valid) bit is clear, 
Device-context whose `V` (valid) bit is clear, non-leaf PDT entries whose `V`
(valid) bit is clear, Process-context whose `V` (valid) bit is clear, or MSI
PTEs whose `V` bit is clear.

These IOATC do not observe modifications to the in-memory data structures using
explicit loads and stores by RISC-V harts or by device DMA. Software must use
the IOMMU commands to invalidate the cached data structure entries using IOMMU
commands to synchronize the IOMMU operations to observe updates to in-memory
data structures. A simpler implementation may not implement IOATC for some or
any of the in-memory data structures. The IOMMU commands may use one or
more IDs to tag the cached entries to identify a specific entry or a
group of entries.

.Identifiers used to tag IOATC entries
[width=90%]
[%header, cols="8,10,10"]
|===
|Data Structure cached  |IDs used to tag entries    | Invalidation command
|Device Directory Table |`device_id`                | <<IDDT, IODIR.INVAL_DDT>>
|Process Directory Table|`device_id`, `process_id`  | <<IPDT, IODIR.INVAL_PDT>>
|S/VS-stage page tables |`GSCID`, `PSCID`, and IOVA | <<IVMA, IOTINVAL.VMA>>
|G-stage page table     |`GSCID`, `GPA`             | <<IGVMA,IOTINVAL.GVMA>>
|MSI page table         |`device_id`,
                         MSI-interrupt-file-number  | <<IMSI, IOTINVAL.MSI>>
|===
